#!/usr/bin/env ruby
# =========================================================================
#   Ceedling - Test-Centered Build System for C
#   ThrowTheSwitch.org
#   Copyright (c) 2010-24 Mike Karlesky, Mark VanderVoord, & Greg Williams
#   SPDX-License-Identifier: MIT
# =========================================================================

require 'rubygems'

# Get the path for our current code directory
ceedling_bin_path = File.expand_path( File.join( File.dirname( __FILE__ ), '..', 'bin' ) )

# Add load path so we can `require` files in bin/
$LOAD_PATH.unshift( ceedling_bin_path )

# Pull in our startup configuration code in bin/
require 'app_cfg'
CEEDLING_APPCFG = CeedlingAppConfig.new()

# Add load paths for `require 'ceedling/*'` statements in bin/ code
$LOAD_PATH.unshift( CEEDLING_APPCFG[:ceedling_lib_base_path] )

require 'cli'          # Located alongside this file in CEEDLING_BIN
require 'constructor'  # Assumed installed via Ceedling gem dependencies

# Entry point
begin
  diy_vendor_path = File.join( CEEDLING_APPCFG[:ceedling_vendor_path], 'diy/lib' )

  # Construct all bootloader objects
  #  1. Add full path to $LOAD_PATH to simplify objects.yml
  #  2. Add vendored DIY to $LOAD_PATH so we can use it
  #  3. Require DIY (used by Ceedling application too)
  #  4. Perform object construction + dependency injection from bin/objects.yml
  #  5. Remove all paths added to $LOAD_PATH
  #     (Main application will restore certain paths -- possibly updated by :which_ceedling)
  $LOAD_PATH.unshift( 
    CEEDLING_APPCFG[:ceedling_lib_path],
    diy_vendor_path
  )

  require 'diy'
  bin_objects_filepath = File.join( ceedling_bin_path, 'objects.yml' )
  objects = DIY::Context.from_yaml( File.read( bin_objects_filepath ) )
  objects.build_everything()
  
  # Remove all load paths we've relied on (main application will set up load paths again)
  $LOAD_PATH.delete( ceedling_bin_path )
  $LOAD_PATH.delete( CEEDLING_APPCFG[:ceedling_lib_path] )
  $LOAD_PATH.delete( diy_vendor_path )

  # Keep a copy of the command line for edge case CLI hacking (Thor consumes ARGV)
  _ARGV = ARGV.clone

  # Especially on Windows, tell Thor & Rake how wide the terminal is
  ENV['THOR_COLUMNS'] = CEEDLING_APPCFG[:terminal_width].to_s()
  ENV['RAKE_COLUMNS'] = ENV['THOR_COLUMNS']

  #
  # NOTE: See comment block in cli.rb to understand CLI handling
  # ------------------------------------------------------------
  #

  # Backwards compatibility command line hack to silently preserve Rake `-T` CLI handling
  if (ARGV.size() == 1 and ARGV[0] == '-T')
    # Call Rake task listing handler w/ default handling of project file and mixins
    objects[:cli_handler].rake_help( env:ENV, app_cfg:CEEDLING_APPCFG )

  # Run command line args through Thor (including "naked" Rake tasks)
  else
    CeedlingTasks::CLI.start( ARGV,
      {
        :app_cfg => CEEDLING_APPCFG,
        :objects => objects,
      }
    )
  end

# Handle case of Thor application CLI failing to handle command line arguments.
rescue Thor::UndefinedCommandError
  # Marrying Thor & Rake command line handling creates a gap (see comments in CLI handling).
  # If a user enters only Rake build tasks at the command line followed by Thor flags,
  # our Thor configuration doesn't see those flags.
  # We catch the exception of unrecognized Thor commands here (i.e. any "naked" Rake tasks),
  # and try again by forcing the Thor `build` command at the beginning of the command line.
  # This way, our Thor handling will process option flags and properly pass the Rake tasks 
  # along as well.
  CeedlingTasks::CLI.start( _ARGV.unshift( 'build' ),
    {
      :app_cfg => CEEDLING_APPCFG,
      :objects => objects,
    }
  )

# Bootloader boom handling (ideally this never runs... we failed to build much if we're here)
rescue StandardError => e
  $stderr.puts( "\nERROR: #{e.message}" )
  $stderr.puts( e.backtrace ) if ( defined?( PROJECT_DEBUG ) and PROJECT_DEBUG )
  exit(1)
end

