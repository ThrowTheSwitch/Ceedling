#!/usr/bin/env ruby
# =========================================================================
#   Ceedling - Test-Centered Build System for C
#   ThrowTheSwitch.org
#   Copyright (c) 2010-24 Mike Karlesky, Mark VanderVoord, & Greg Williams
#   SPDX-License-Identifier: MIT
# =========================================================================

require 'rubygems'

CEEDLING_ROOT     = File.expand_path( File.join( File.dirname( __FILE__ ), ".." ) )
CEEDLING_BIN      = File.join( CEEDLING_ROOT, 'bin' )
CEEDLING_LIB_BASE = File.join( CEEDLING_ROOT, 'lib' )
CEEDLING_LIB      = File.join( CEEDLING_LIB_BASE, 'ceedling' )
CEEDLING_VENDOR   = File.join( CEEDLING_ROOT, 'vendor' )

# Add load path for `require 'ceedling/*'` statements and bin/ code
$LOAD_PATH.unshift( CEEDLING_BIN, CEEDLING_LIB_BASE )

require 'cli'          # Located alongside this file in CEEDLING_BIN
require 'constructor'  # Assumed installed via Ceedling gem dependencies
require 'app_cfg'      # Located alongside this file in CEEDLING_BIN

CEEDLING_APPCFG = get_app_cfg()

# Entry point
begin
  # Construct all bootloader objects
  #  1. Add full path to $LOAD_PATH to simplify objects.yml
  #  2. Add vendored DIY to $LOAD_PATH so we can use it
  #  3. Require DIY (used by Ceedling application too)
  #  4. Perform object construction + dependency injection from bin/objects.yml
  #  5. Remove unneeded / potentially problematic paths from $LOAD_PATH
  $LOAD_PATH.unshift( CEEDLING_LIB )
  $LOAD_PATH.unshift( File.join(CEEDLING_VENDOR, 'diy/lib') )

  require 'diy'
  objects = DIY::Context.from_yaml( File.read( File.join( CEEDLING_BIN, 'objects.yml' ) ) )
  objects.build_everything()
  
  $LOAD_PATH.delete( CEEDLING_BIN ) # Loaded in top-level `ceedling` script
  $LOAD_PATH.delete( CEEDLING_LIB )

  # Keep a copy of the command line for edge case CLI hacking (Thor consumes ARGV)
  _ARGV = ARGV.clone

  #
  # NOTE: See comment block in cli.rb to understand CLI handling
  # ------------------------------------------------------------
  #

  # Backwards compatibility command line hack to silently preserve Rake `-T` CLI handling
  if (ARGV.size() == 1 and ARGV[0] == '-T')
    # Call Rake task listing handler w/ default handling of project file and mixins
    objects[:cli_handler].rake_help( env:ENV, app_cfg:CEEDLING_APPCFG )

  # Run command line args through Thor (including "naked" Rake tasks)
  else
    CeedlingTasks::CLI.start( ARGV,
      {
        :app_cfg => CEEDLING_APPCFG,
        :objects => objects,
      }
    )
  end

# Handle case of Thor application CLI failing to handle command line arguments.
rescue Thor::UndefinedCommandError
  # Marrying Thor & Rake command line handling creates a gap (see comments in CLI handling).
  # If a user enters only Rake build tasks at the command line followed by Thor flags,
  # our Thor configuration doesn't see those flags.
  # We catch the exception of unrecognized Thor commands here (i.e. any "naked" Rake tasks),
  # and try again by forcing the Thor `build` command at the beginning of the command line.
  # This way, our Thor handling will process option flags and properly pass the Rake tasks 
  # along as well.
  CeedlingTasks::CLI.start( _ARGV.unshift( 'build' ),
    {
      :app_cfg => CEEDLING_APPCFG,
      :objects => objects,
    }
  )

# Bootloader boom handling (ideally this never runs... we failed to build much if we're here)
rescue StandardError => e
  $stderr.puts( "\nERROR: #{e.message}" )
  $stderr.puts( e.backtrace ) if ( defined?( PROJECT_DEBUG ) and PROJECT_DEBUG )
  exit(1)
end

